#define alpha 0.04#define THRESHOLD 1e7#define S 0.7#define epsilon 1.4void DetecteurHarris(cv::Mat src, cv::Mat &dst, float sigmaI, float sigmaD){cv::Mat Ix(src.rows, src.cols, src.depth());cv::Mat Iy(src.rows, src.cols, src.depth());cv::Mat Gx(src.rows, src.cols, src.depth());cv::Mat Gy(src.rows, src.cols, src.depth());cv::Mat Lx(src.rows, src.cols, src.depth());cv::Mat Ly(src.rows, src.cols, src.depth());cv::Mat laplacianImage(src.rows, src.cols, src.depth());cv::Mat cornerRImage(src.rows, src.cols, CV_16U);cv::Mat sobelImage(src.rows, src.cols, src.depth());cv::Mat gaussianImage(src.rows, src.cols, src.depth());/* Calcul de Ix et Iy gradient en x et en y d’une image listée àl’aide de l’opérateur de Sobel*/GaussianBlur(src, gaussianImage, cvSize(3, 3), sigmaD);Sobel(gaussianImage, Ix, gaussianImage.depth(), 0, 1, 3);Sobel(gaussianImage, Iy, gaussianImage.depth(), 1, 0, 3);//Calcul des produits de I, lisser avec un filtre gaussienGaussianBlur(Ix, Gx, cvSize(3, 3), sigmaI);GaussianBlur(Iy, Gy, cvSize(3, 3), sigmaI);Laplacian(Ix, Lx, gaussianImage.depth(), 3);Laplacian(Iy, Ly, gaussianImage.depth(), 3);
float xx = x * x;float yy = y * y;float xy = x * y;xx *= sigmaD * sigmaD;yy *= sigmaD * sigmaD;xy *= sigmaD * sigmaD;float det = xx * yy - xy*xy;float tr = xx + yy;int R = round(fabs(det - alpha * tr * tr));cornerR[i + j * Gx.rows] = R;LoG[i + j * Gx.rows] =sigmaI * sigmaI * abs(Lx.at<char>(i, j) + Ly.at<char>(i, j));}}cv::Mat cornerImage(src.rows, src.cols, src.depth());cornerImage.setTo(0);/*Extraire les maxima locaux positifs sur un voisinage 3 (mettre à0 tous les points négatifs ou dont la valeur n’est pas supérieureàcelle des 8 voisins )*/for (int i = 1; i < cornerRImage.rows - 1; i++) {for (int j = 1; j < cornerRImage.cols - 1; j++) {int center = cornerR[i + j * cornerRImage.rows];
bool condition = true;if (center > THRESHOLD) {for (int m = -1; m <= 1; m++) {for (int n = -1; n <= 1; n++) {if (n == 0 && m == 0) continue;int neighbour = cornerR[i + m + (j + n) * cornerRImage.rows];if (neighbour >= center) {condition = false;}}}if (condition) {
counter++;cornerImage.at<uchar > (i, j) = 255;}}}}delete [] cornerR;delete [] LoG;imshow("Corners", cornerImage);cv::waitKey();}int main(int argc, char* argv[]) {cv::string inputImageName;cv::Mat inputImage = cvLoadImageM("../ImageMatchingImages/graffiti/img1.ppm");cv::Mat grayImage(inputImage.rows, inputImage.cols, 0);cvtColor(inputImage, grayImage, CV_RGB2GRAY);imshow("Img", grayImage);cv::waitKey();
float sigma0 = 1.0f;float sigmaI = sigma0;float sigmaD = 0;sigmaD = sigmaI * S;DetecteurHarris(grayImage, inputImage, sigmaI, sigmaD);return EXIT_SUCCESS;}float kernelW(int x, int y, int sigma) {int sigmaSqr = sigma * sigma;int xSqr = x * x;int ySqr = y * y;return pow(M_E, -((xSqr + ySqr) / (2 * sigmaSqr))) / (2 * M_PI * sigmaSqr);}